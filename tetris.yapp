{
  "appId": "com.yos.tetris",
  "name": "Tetris",
  "version": "1.0.0",
  "minOSVersion": "0.1.0",
  "maxOSVersion": null,
  "developer": "Classic Games Inc.",
  "category": "games",
  "description": "Classic block-stacking puzzle game. Use arrow keys to move and rotate blocks.",
  "icon": "<svg viewBox=\"0 0 100 100\"><rect x=\"10\" y=\"10\" width=\"80\" height=\"80\" rx=\"8\" fill=\"#1a1a1a\" stroke=\"#333\" stroke-width=\"2\"/><rect x=\"20\" y=\"20\" width=\"12\" height=\"12\" fill=\"#ff6b6b\" stroke=\"#000\" stroke-width=\"1\"/><rect x=\"32\" y=\"20\" width=\"12\" height=\"12\" fill=\"#ff6b6b\" stroke=\"#000\" stroke-width=\"1\"/><rect x=\"44\" y=\"20\" width=\"12\" height=\"12\" fill=\"#ff6b6b\" stroke=\"#000\" stroke-width=\"1\"/><rect x=\"56\" y=\"20\" width=\"12\" height=\"12\" fill=\"#ff6b6b\" stroke=\"#000\" stroke-width=\"1\"/><rect x=\"32\" y=\"40\" width=\"12\" height=\"12\" fill=\"#4dabf7\" stroke=\"#000\" stroke-width=\"1\"/><rect x=\"44\" y=\"40\" width=\"12\" height=\"12\" fill=\"#4dabf7\" stroke=\"#000\" stroke-width=\"1\"/></svg>",
  "window": {
    "width": 360,
    "height": 520,
    "resizable": false,
    "hasMinimize": true,
    "hasMaximize": true,
    "defaultPosition": {
      "top": 80,
      "left": 200
    }
  },
  "permissions": ["storage"],
  "html": "<div style=\"display:flex;gap:10px;padding:10px;background:#000;height:100%;box-sizing:border-box;\"><canvas id=\"tetris-canvas\" width=\"300\" height=\"600\" style=\"border:2px solid #333;background:#000;flex-shrink:0;\"></canvas><div class=\"game-info\" style=\"flex-shrink:0;width:140px;background:#1a1a1a;padding:15px;border-radius:5px;color:#fff;\"><div class=\"game-score\" style=\"font-size:14px;font-weight:bold;margin-bottom:10px;\">Score: <span id=\"tetris-score\">0</span></div><div class=\"game-level\" style=\"font-size:14px;font-weight:bold;margin-bottom:10px;\">Level: <span id=\"tetris-level\">1</span></div><div class=\"game-controls\" style=\"margin:20px 0;font-size:11px;line-height:1.8;opacity:0.8;\"><p>← → Move</p><p>↑ Rotate</p><p>↓ Drop</p><p>Space: Fast Drop</p></div><button id=\"tetris-restart\" style=\"width:100%;padding:8px;background:#4dabf7;color:#fff;border:none;border-radius:4px;font-weight:bold;cursor:pointer;margin-top:10px;\">Restart</button></div></div>",
  "css": ".game-btn:hover{background:#339af0}.game-btn:active{background:#1971c2}",
  "js": "(function(container){const canvas=container.querySelector('#tetris-canvas');const ctx=canvas.getContext('2d');const scoreEl=container.querySelector('#tetris-score');const levelEl=container.querySelector('#tetris-level');const restartBtn=container.querySelector('#tetris-restart');const COLS=10,ROWS=20,BLOCK_SIZE=30;let board=[],currentPiece,score=0,level=1,gameOver=false,dropInterval;const PIECES=[[[1,1,1,1]],[[1,1],[1,1]],[[0,1,0],[1,1,1]],[[1,0,0],[1,1,1]],[[0,0,1],[1,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,1]]];const COLORS=['#00f0f0','#f0f000','#a000f0','#f0a000','#0000f0','#00f000','#f00000'];const initBoard=()=>{board=Array(ROWS).fill().map(()=>Array(COLS).fill(0))};const drawBlock=(x,y,color)=>{ctx.fillStyle=color;ctx.fillRect(x*BLOCK_SIZE,y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);ctx.strokeStyle='#000';ctx.strokeRect(x*BLOCK_SIZE,y*BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE)};const drawBoard=()=>{ctx.fillStyle='#000';ctx.fillRect(0,0,canvas.width,canvas.height);for(let y=0;y<ROWS;y++){for(let x=0;x<COLS;x++){if(board[y][x])drawBlock(x,y,COLORS[board[y][x]-1])}}};const newPiece=()=>{const type=Math.floor(Math.random()*PIECES.length);return{shape:PIECES[type],color:type+1,x:3,y:0}};const drawPiece=(piece)=>{piece.shape.forEach((row,y)=>{row.forEach((value,x)=>{if(value)drawBlock(piece.x+x,piece.y+y,COLORS[piece.color-1])})})};const collision=(piece,offsetX=0,offsetY=0)=>{for(let y=0;y<piece.shape.length;y++){for(let x=0;x<piece.shape[y].length;x++){if(piece.shape[y][x]){const newX=piece.x+x+offsetX;const newY=piece.y+y+offsetY;if(newX<0||newX>=COLS||newY>=ROWS)return true;if(newY>=0&&board[newY][newX])return true}}}return false};const merge=(piece)=>{piece.shape.forEach((row,y)=>{row.forEach((value,x)=>{if(value)board[piece.y+y][piece.x+x]=piece.color})})};const clearLines=()=>{let linesCleared=0;for(let y=ROWS-1;y>=0;y--){if(board[y].every(cell=>cell!==0)){board.splice(y,1);board.unshift(Array(COLS).fill(0));linesCleared++;y++}}if(linesCleared>0){score+=linesCleared*100*level;scoreEl.textContent=score;level=Math.floor(score/1000)+1;levelEl.textContent=level}};const rotate=(piece)=>{const newShape=piece.shape[0].map((_,i)=>piece.shape.map(row=>row[i]).reverse());const oldShape=piece.shape;piece.shape=newShape;if(collision(piece))piece.shape=oldShape};const drop=()=>{if(!gameOver&&!collision(currentPiece,0,1)){currentPiece.y++}else if(!gameOver){merge(currentPiece);clearLines();currentPiece=newPiece();if(collision(currentPiece)){gameOver=true;alert('Game Over! Score: '+score)}}draw()};const draw=()=>{drawBoard();if(currentPiece)drawPiece(currentPiece)};const startGame=()=>{initBoard();currentPiece=newPiece();score=0;level=1;gameOver=false;scoreEl.textContent='0';levelEl.textContent='1';if(dropInterval)clearInterval(dropInterval);dropInterval=setInterval(drop,1000);draw()};document.addEventListener('keydown',(e)=>{if(gameOver)return;if(e.key==='ArrowLeft'&&!collision(currentPiece,-1,0))currentPiece.x--;else if(e.key==='ArrowRight'&&!collision(currentPiece,1,0))currentPiece.x++;else if(e.key==='ArrowDown'&&!collision(currentPiece,0,1))currentPiece.y++;else if(e.key==='ArrowUp')rotate(currentPiece);else if(e.key===' '){while(!collision(currentPiece,0,1))currentPiece.y++}draw()});restartBtn.addEventListener('click',startGame);startGame()})"
}